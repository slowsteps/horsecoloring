package  {		import com.adobe.ane.productStore.Product;    import com.adobe.ane.productStore.ProductEvent;    import com.adobe.ane.productStore.ProductStore;    import com.adobe.ane.productStore.Transaction;    import com.adobe.ane.productStore.TransactionEvent;	import flash.net.SharedObject;	import flash.net.URLLoader	import flash.net.URLRequest	import flash.events.*	import flash.display.Sprite	import com.sticksports.nativeExtensions.flurry.Flurry				public class InappManager extends EventDispatcher{				private var mymain:Main		public var productStore:ProductStore		public var inappReadyForBuying:Boolean = false		private var myproductid:String = "com.wungi.horsecoloring.unlockall.one"		public var buyingmode:String		public var dp:EventDispatcher				public function InappManager(inmain,inbuyingmode:String="purchase") {			trace("new inappmanager")			mymain = inmain						mymain.console.log( "in InappManager");			if (Flurry.isSupported) Flurry.logEvent("inappmanager created")			mymain.console.log( "passed Flurry");			buyingmode = inbuyingmode						checkOnline() //need to be online do to do inapps					}				public function checkOnline() {			//ONLINE CHECK			mymain.console.log( "in checkOnline");						var cookie:SharedObject = SharedObject.getLocal("horsecoloring");			var stats:String=""			if (cookie) stats = "numplays=" + cookie.data.numPlays + "&drawing0=" + cookie.data.drawing0 						var req:URLRequest = new URLRequest("http://www.wungi.com/stats.php/?data="+stats)			var loader:URLLoader = new URLLoader();			loader.addEventListener(Event.COMPLETE, onUrlLoaded);			loader.addEventListener(IOErrorEvent.IO_ERROR,httpRequestError )    		loader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, httpRequestError ); 						loader.load(req);		}		private function onUrlLoaded(e:Event) {			//device online, ready to move on			trace("wungi stats service online: " + e.target.data)			mymain.console.log( "in onUrlLoaded" + e.target.data);			if (check_isSupported()) {				get_Product()			}			else {				mymain.alert("in app purchase not possible")				mymain.dispatcher.dispatchEvent(new CustomEvent(CustomEvent.ON_INAPP_CANCELLED))			}		}				private function httpRequestError(e:ErrorEvent) {			mymain.console.log( "in httpRequestError " + e.type);			//device not online, inform user and halt			trace("Cannot acces wungi stats service, device might be offline. Error: " + e.type)			mymain.alert("Please go online if you want to unlock all drawings")			mymain.dispatcher.dispatchEvent(new CustomEvent(CustomEvent.ON_INAPP_CANCELLED))		}	  	protected function check_isSupported():Boolean {			mymain.console.log( "in check_isSupported ");			productStore=new ProductStore()												//ON DEVICE AND ENABLED			trace("product store is supported: "+ ProductStore.isSupported); //on device			trace("product store is available: "+ productStore.available);  //user has not blocked inapp									if (ProductStore.isSupported && productStore.available ) {				productStore.addEventListener(TransactionEvent.PURCHASE_TRANSACTION_SUCCESS, purchaseTransactionSucceeded);				productStore.addEventListener(TransactionEvent.PURCHASE_TRANSACTION_CANCEL, purchaseTransactionCanceled);				productStore.addEventListener(TransactionEvent.PURCHASE_TRANSACTION_FAIL, purchaseTransactionFailed);								productStore.addEventListener(TransactionEvent.RESTORE_TRANSACTION_SUCCESS, restoreTransactionSucceeded);				productStore.addEventListener(TransactionEvent.RESTORE_TRANSACTION_FAIL, restoreTransactionFailed);				productStore.addEventListener(TransactionEvent.RESTORE_TRANSACTION_COMPLETE,  restoreTransactionCompleted);				return true			}			else {				return false			}		}						public function get_Product():void {			mymain.console.log("in get_Product");			productStore.addEventListener(ProductEvent.PRODUCT_DETAILS_SUCCESS,productDetailsSucceeded);			productStore.addEventListener(ProductEvent.PRODUCT_DETAILS_FAIL, productDetailsFailed);						var vector:Vector.<String> = new Vector.<String>(1);			vector[0] = myproductid;			productStore.requestProductsDetails(vector);			mymain.console.log( "requesting details for: "+ vector);		}				public function productDetailsSucceeded(e:ProductEvent):void {			mymain.console.log("DETAILS SUCCESS "+e);			var i:uint=0;			while(e.products && i < e.products.length)			{				var p:Product = e.products[i];				mymain.console.log("Product details:")				mymain.console.log("- title: "+p.title);				mymain.console.log("- description: "+p.description);				mymain.console.log("- identifier: "+p.identifier);				mymain.console.log("- priceLocale: "+p.priceLocale);				mymain.console.log("- price:"+p.price);				i++;			}						inappReadyForBuying = true			//check if player already bought the product and if so, act on it.			if (buyingmode == "purchase") makePurchase()        	else if (buyingmode == "restore") restore_Transactions()			else mymain.console.log("unknown buying mode: " + buyingmode)		}				public function productDetailsFailed(e:ProductEvent):void {			mymain.console.log("DETAILS FAILED"+e);			var i:uint=0;			while(e.invalidIdentifiers && i < e.invalidIdentifiers.length)			{				mymain.console.log(e.invalidIdentifiers[i]);				i++;			}		}						public function makePurchase() {			if (this.inappReadyForBuying) {				mymain.console.log("in makepurchase")				productStore.makePurchaseTransaction(myproductid,1);			}			else mymain.console.log("in apps not ready for buying")		}				//SUCCESFUL SALE		protected function purchaseTransactionSucceeded(e:TransactionEvent):void {			 mymain.console.log("PURCHASE SUCCES " +e);			 mymain.dispatcher.dispatchEvent(new CustomEvent(CustomEvent.ON_INAPP_BUY))			 if (Flurry.isSupported) Flurry.logEvent("transaction succes")			 var i:uint=0;			 while(e.transactions && i < e.transactions.length)			 {			   var t = e.transactions[i];			   printTransaction(t);			   i++;			 }			 getPendingTransaction(productStore);			 mymain.alert("Drawings unlocked!")		}		protected function purchaseTransactionCanceled(e:TransactionEvent):void{			mymain.console.log("CANCELLED "+e);			var i:uint=0;			mymain.alert("Transaction cancelled")			mymain.dispatcher.dispatchEvent(new CustomEvent(CustomEvent.ON_INAPP_CANCELLED))						while(e.transactions && i < e.transactions.length)			{				var t:Transaction = e.transactions[i];				//printTransaction(t);				i++;				productStore.addEventListener(TransactionEvent.FINISH_TRANSACTION_SUCCESS, finishTransactionSucceeded);				productStore.finishTransaction(t.identifier);			}			getPendingTransaction(productStore);		}            		protected function purchaseTransactionFailed(e:TransactionEvent):void		{			mymain.console.log("FAILED "+e);			var i:uint=0;			mymain.alert("Transaction failed")			while(e.transactions && i < e.transactions.length)			{				var t:Transaction = e.transactions[i];				//printTransaction(t);				i++;				productStore.addEventListener(TransactionEvent.FINISH_TRANSACTION_SUCCESS, finishTransactionSucceeded);				productStore.finishTransaction(t.identifier);			}			getPendingTransaction(productStore);		}				//BEGIN RESTORE		//CALLED FROM THUMB		public function restore_Transactions():void {						mymain.console.log("RESTORING TRANSACTION");			//mymain.alert("Restoring transaction")						productStore.restoreTransactions();			        }				 protected function restoreTransactionSucceeded(e:TransactionEvent):void {			mymain.console.log("RESTORE SUCCEED");			mymain.console.log("RESTORE SUCCEED LONG VERSION " +e);			mymain.alert("Restore succesful")						var i:uint=0;			while(e.transactions && i < e.transactions.length)			{				var t:Transaction = e.transactions[i];				printTransaction(t);				i++;				mymain.console.log("FinishTransactions" + t.identifier);				productStore.addEventListener(TransactionEvent.FINISH_TRANSACTION_SUCCESS, finishTransactionSucceeded);				productStore.finishTransaction(t.identifier);			}						getPendingTransaction(productStore);         }            		protected function restoreTransactionFailed(e:TransactionEvent):void {			mymain.console.log("RESTORE FAILED " +e);			mymain.dispatcher.dispatchEvent(new CustomEvent(CustomEvent.ON_INAPP_CANCELLED))		}            		protected function restoreTransactionCompleted(e:TransactionEvent):void{			mymain.console.log("RESTORE COMPLETED " +e);					}						//END RESTORE            		//FINISH MUST ALWAYS BE CALLED		protected function finishTransactionSucceeded(e:TransactionEvent):void{			mymain.console.log("TRANSACTION FINISH " +e);			var i:uint=0;			while(e.transactions && i < e.transactions.length)			{				var t:Transaction = e.transactions[i];				printTransaction(t);				i++;			}		}				public function getPendingTransaction(prdStore:ProductStore):void		{			trace("TRANSACTION PENDING");			var transactions:Vector.<Transaction> = prdStore.pendingTransactions; 			var i:uint=0;			while(transactions && i<transactions.length)			{				var t:Transaction = transactions[i];				//printTransaction(t);				i++;			}		}								public function printTransaction(t:Transaction):void {			mymain.console.log("\n-------------------in Print Transaction----------------------");			mymain.console.log("identifier :"+t.identifier);			mymain.console.log("productIdentifier: "+ t.productIdentifier);			mymain.console.log("productQuantity: "+t.productQuantity);			mymain.console.log("date: "+t.date);			mymain.console.log("receipt: "+t.receipt);			mymain.console.log("error: "+t.error);			mymain.console.log("originalTransaction: "+t.originalTransaction);			if(t.originalTransaction)				printTransaction(t.originalTransaction);			mymain.console.log("---------end of print transaction----------------------------\n");        			}        			}	}
package  {	import flash.display.MovieClip;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.BlendMode;	import flash.events.MouseEvent;	import flash.events.TouchEvent;	import flash.events.ErrorEvent	import flash.events.UncaughtErrorEvent	import flash.ui.Multitouch;	import flash.ui.MultitouchInputMode;	import flash.events.Event;	import flash.geom.ColorTransform;	import flash.geom.Rectangle;	import flash.geom.Point;	import flash.net.URLRequest;	import flash.net.URLLoader;	import flash.net.navigateToURL;	import flash.geom.Matrix;	import fl.transitions.Tween; 	import fl.transitions.easing.*; 	import flash.filters.BitmapFilter; 	import fl.transitions.TweenEvent; 	import flash.utils.Timer; 	import flash.events.TimerEvent;	import flash.events.Event;	import flash.ui.Mouse;	import flashx.textLayout.formats.BackgroundColor;	import flash.text.TextField;	import flash.net.SharedObject;	import com.greensock.TweenMax;	import com.greensock.*;	import com.greensock.easing.*;	import flash.media.CameraRoll;	import flash.media.Sound	import flash.system.Capabilities	import flash.events.EventDispatcher	import flash.display.StageAlign;  	import flash.display.StageScaleMode;	import flash.display.DisplayObject	import flash.display.DisplayObjectContainer	import com.sticksports.nativeExtensions.flurry.Flurry	import flash.desktop.NativeApplication		import flash.media.SoundChannel;	public class Main extends flash.display.MovieClip {		var bmdataColors:BitmapData; // floodfill color layer		var bmdataOutlines:BitmapData; //outline layer incl. new user drawn outlines.		var bmdataOriginalOutlines:BitmapData; //outline layer incl. new user drawn outlines.		var bmdataPattern:BitmapData; //stamps layer (flowers etc)		var bmdataBackdrop:BitmapData; //huh		var brushcanvas:MovieClip		var picscaleY:Number = 0.75		var colSwatch:MovieClip;		var clickLogo:MovieClip;		var resetButton:MovieClip;		var menuButton:MovieClip;		var cameraButton:MovieClip;		var mainMenu:MovieClip;		var numColSwatchesSelected:int=0;		var colors:Array;		var colorNames:Array;		var colorLookup:Array;		var curcolor:uint=0xFFFF8C00;		var curColorName:String		var curPatternNum:int=0;		var curPattern;		var curPatternName:String;		var savePattern;		var lastClicked;		var patterns:Array;		var padding = 15;		var canvas;		var drawMode:String = "color";		var clicks:int;		var customCursor:MovieClip;		var sprayTimer:Timer;		var lastX:Number;		var lastY:Number;		//resolution independent helpers		var gameWidth:Number = 1024;		var gameHeight:Number = 768;		var spacing:Number		var stagePadding:Number = 20;		var clickX:Number;		var clickY:Number;		public var gameState:String = "coloring"		public var achievementManager:AchievementManager		public var inAppManager:InappManager		public var payingUser:Boolean = false		public var numPlays:int=0		public var cookie:SharedObject		public var console:DebugConsole		public var msg:Message		private var frog:MovieClip		public var boingSound:Sound		private var surpriseTimer:Timer		public var dispatcher:EventDispatcher		private var currentDrawingNumber:int=-1		private var curDrawingName:String=null		public var clickSound:Sound		public var coloringSongSound:Sound		public var natureSoundsSound:Sound		public var songChannel:SoundChannel		public var natureSongChannel:SoundChannel		public var musicTimer:Timer		public var appversion:Number=2				public function Main() {						//this.x = -(gameWidth - Capabilities.screenResolutionX)						stage.scaleMode = StageScaleMode.NO_SCALE;			      		stage.align = StageAlign.TOP_LEFT;						dispatcher = new EventDispatcher()		    			canvas = new MovieClip();								createDebugConsole()			createColors()			createPatterns()			selectDrawing()			//createBackground()			createCanvas()							loadUserData()			createInApps()			createSurprises()			createUtilities()						createFlurry()									Multitouch.inputMode = MultitouchInputMode.TOUCH_POINT;			this.canvas.addEventListener(TouchEvent.TOUCH_BEGIN,onClickDown)			this.canvas.addEventListener(TouchEvent.TOUCH_END,onClickUp)			this.canvas.addEventListener(TouchEvent.TOUCH_MOVE,onMove);			this.dispatcher.addEventListener(CustomEvent.ON_INAPP_BUY,onPaid)			NativeApplication.nativeApplication.addEventListener(Event.ACTIVATE,onActivate) 			 			newSession()											}				private function onActivate(e:Event) {			loadUserData()			newSession()			Flurry.logEvent("app activated",{payinguser:payingUser,numplays:numPlays})		}				private function createCanvas() {			//LAYER 1						addChild(canvas);			canvas.addChild(new Bitmap(bmdataColors));			canvas.x = stage.fullScreenWidth/2 - (bmdataColors.width/2)						//LAYER 2			bmdataBackdrop = new BitmapData(stage.fullScreenWidth,stage.fullScreenHeight,true,0x00000000)			var backdropbm = new Bitmap(bmdataBackdrop)			var backdropclip = this.canvas.addChild(backdropbm);						this.setChildIndex(canvas,0);						//LINE BRUSH LAYER TO COPY FROM			brushcanvas= new MovieClip()			//addChild(brushcanvas)					}						private function onCancel(e:Event) {			trace("cancel!")		}				private function createFlurry() {			if (Flurry.isSupported ) {				trace("flurry supported")				Flurry.setAppVersion("1.0")				Flurry.startSession("DBQTSKXCW2BV2GKNRVZC");			}			else {				trace("flurry unsupported")				//alert("flurry unsupported")			}		}						//var frametick:Number = 0				var bmdataFxBuffer:BitmapData = new BitmapData(stage.fullScreenWidth,stage.fullScreenHeight)				function onAnimateFX(e:Event) {						var mat:Matrix=new Matrix();			var scalefactor = 1.01			//mat.scale(scalefactor,scalefactor);						//mat.rotate(-40*0.017 + 80*Math.random()*0.017);			mat.translate(0,0);			var CT = new ColorTransform(1,1,1,0.98,0,0,0,0.0)			bmdataFxBuffer.copyPixels(this.bmdataBackdrop,new Rectangle(0,0,stage.fullScreenWidth,stage.fullScreenHeight),new Point(0,0),null,null,false)			bmdataBackdrop.fillRect(new Rectangle(0,0,stage.fullScreenWidth,stage.fullScreenHeight),0x00000000);			this.bmdataBackdrop.draw(this.bmdataFxBuffer,mat,CT,null,null,false)								}		function onMove(e) {			clickX = e.localX;			clickY = e.localY;		}		function onSpray(e) {			//called by sprayTimer, to start regular spray of pattern stamps						this.drawPattern(clickX,clickY);			this.redrawSavedDrawing();		}		function onClickUp(e) {						//stop straying patterns			sprayTimer.stop();			//stop drawing with the brush			this.canvas.removeEventListener(TouchEvent.TOUCH_MOVE,onDrawWithBrush)		}		function redrawSavedDrawing() {			bmdataColors.copyPixels(bmdataOutlines,new Rectangle(0,0,bmdataColors.width,bmdataColors.height),new Point(0,0),null,null,true);		}		function redrawOriginalDrawing() {			bmdataColors.copyPixels(bmdataOriginalOutlines,new Rectangle(0,0,bmdataColors.width,bmdataColors.height),new Point(0,0),null,null,true);			bmdataOutlines.copyPixels(bmdataOriginalOutlines,new Rectangle(0,0,bmdataColors.width,bmdataColors.height),new Point(0,0),null,null,true);		}				//function onDrawWithBrush(e:TouchEvent) {  UNDO		function onDrawWithBrush(e:TouchEvent) {						//interpolate between mousemove events to prevent gaps in lines			/*			var numsteps = 20			var stepX = (e.localX - lastX)/numsteps;			var stepY = (e.localY - lastY)/numsteps;						//clear once			for (var i=0;i<numsteps;i++) {				this.drawPattern( (lastX + i*stepX), (lastY + i*stepY));			}			*/			var linewidth = Math.round(8*stage.fullScreenWidth/1024)			brushcanvas.graphics.clear()			brushcanvas.graphics.lineStyle(linewidth,0x000000)						brushcanvas.graphics.moveTo(lastX,lastY)			brushcanvas.graphics.lineTo(e.localX,e.localY)						bmdataOutlines.draw(brushcanvas)			this.redrawSavedDrawing();						lastX = e.localX;			lastY = e.localY;								}				//A color swatch is clicked		public function setColSwatch(colswatch: Swatch) {			curcolor = colswatch.col;			this.curColorName = colswatch.colname;		}				//A stamp ("pattern") swatch is clicked		public function setPattern(inPattern:Pattern,inNum:int) {						curPatternName = inPattern.patternName						curPatternNum = inNum			//if (savePattern != null) savePattern.releaseFocus()			this.savePattern = inPattern										}				public function onSwatchClick(swatch) {						if (lastClicked != null) lastClicked.releaseFocus()			lastClicked = swatch					}						public function animBounce(inclip:MovieClip,origScaleX:Number,origScaleY:Number) {			var myTween1:Tween = new Tween(inclip, "scaleX", Elastic.easeOut, 1.5*origScaleX, origScaleX, 2, true);			var myTween2:Tween = new Tween(inclip, "scaleY", Elastic.easeOut, 1.5*origScaleY, origScaleY, 2, true);		}		public function animBounceBack(inclip:MovieClip,origScaleX:Number,origScaleY:Number) {						var myTween1:Tween = new Tween(inclip, "scaleX", Regular.easeInOut, inclip.scaleX, origScaleX, 1, true);			var myTween2:Tween = new Tween(inclip, "scaleY", Regular.easeIn, inclip.scaleY, origScaleY, 1, true);		}		public function animFlyin(inclip) {			var duration:Number = 1;			new Tween(inclip, "x", Regular.easeInOut, -inclip.width, inclip.x, duration, true);					}		private function drawPattern(inX,inY) {			//the position on the canvas where the pattern need to be drawn			var posx = inX - (bmdataPattern.width/2);			var posy = inY - (bmdataPattern.height/2);						curPattern = patterns[curPatternNum];					//clear			if (curPattern.isBrush) {				//no need to clear, just draw the same brushtip over and over again			}			else {				//patterns are rotated etc, so needs to be cleared for next drawcycle				bmdataPattern.fillRect(new Rectangle(0,0,bmdataPattern.width,bmdataPattern.height),0x00000000);			}			//draw						//some random effects to make each stamp look a bit different, keep it clean for brushes						var mat:Matrix=new Matrix();			var scalefactor = (0.4 + 0.6*Math.random()) * (stage.fullScreenWidth/1024)			//scale the stamp patterns, not the brush			if (!curPattern.isBrush) mat.scale(scalefactor,scalefactor);			if (!curPattern.isBrush) mat.rotate(-40*0.017 + 80*Math.random()*0.017);			mat.translate(bmdataPattern.width/2,bmdataPattern.height/2);						//intermediate draw pass for transformation			//brush icon is not used for drawing, it's child "stamp" is.			if (curPattern.isBrush) {				bmdataPattern.draw(curPattern.stamp,mat)			}			else {				bmdataPattern.draw(curPattern,mat)							}						if (curPattern.isBrush) {				//only copy the	small brushtip. no need to clear because brush is not scaled or rotated							var centerx = (bmdataPattern.width/2) - (curPattern.width/2)				var centery = (bmdataPattern.height/2) - (curPattern.height/2)				//bmdataOutlines.copyPixels(bmdataPattern,new Rectangle(centerx,centery,curPattern.width,curPattern.height),new Point(posx+centerx,posy+centery),null,null,true);											}							else {				//draw color fills in backdrop layer				bmdataBackdrop.copyPixels(bmdataPattern,new Rectangle(0,0,bmdataColors.width,bmdataColors.height),new Point(posx,posy),null,null,true);							}			//			//					}		private function onClickDown(e) {									if (drawMode == "color") {				bmdataColors.floodFill(e.localX,e.localY,curcolor);			}			else if (drawMode == "pattern") {				//draw once straight away and start spraying if mouse stays down				drawPattern(e.localX,e.localY);					sprayTimer.start();			}			else if (drawMode == "brush") {				//keep drawing line until mouse up.				//clear once								bmdataPattern.fillRect(new Rectangle(0,0,bmdataPattern.width,bmdataPattern.height),0x00000000);				lastX=e.localX				lastY=e.localY				drawPattern(e.localX,e.localY);								this.canvas.addEventListener(TouchEvent.TOUCH_MOVE,onDrawWithBrush);							}			else trace("unknown drawmode: " + drawMode)			//redraw outlines			this.redrawSavedDrawing();								}		private function onLogoClick(e:Event) {						var url:URLRequest = new URLRequest("http://www.sohorses.com");			navigateToURL(url,"_blank");								}		private function  createColors() {			colors = new Array();			colorNames = new Array();									colors.push(0xFFFF0000);			colorNames.push("red");			colors.push(0xFF0DD124);			colorNames.push("green");			colors.push(0xFF3c32ff);			colorNames.push("blue");			colors.push(0xFFB88A00);			colorNames.push("light brown");			colors.push(0xFFFF33CC);			colorNames.push("pink");			colors.push(0xFFFF8C00);			colorNames.push("orange");			colors.push(0xFF8c1eb5);			colorNames.push("purple");			colors.push(0xFFFFFF00);			colorNames.push("yellow");			colors.push(0xFF6FAAFD);			colorNames.push("light blue");			colors.push(0xFFf4e9b7);			colorNames.push("sand");			colors.push(0xFFB0B0B0);			colorNames.push("grey");			colors.push(0xFFFFFFFF);			colorNames.push("white");			colors.push(0xFF000001);			colorNames.push("black");			spacing = (stage.fullScreenWidth / (colors.length + 1))						//line up the color swatches			for (var i=0;i<colors.length;i++) {				colSwatch = new Swatch();				addChild(colSwatch);				//colSwatch.x = padding + colSwatch.width/2 + (colSwatch.width + padding)*i; 				colSwatch.x = spacing + (spacing*i)								//colSwatch.y = gameHeight - 120;				colSwatch.y = 0.8*stage.fullScreenHeight;				colSwatch.mymain = this;				colSwatch.setColor(colors[i],i,colorNames[i]);							}					}				private function createPatterns() {						patterns = new Array();			patterns.push(new Grass());			patterns.push(new Flower());			patterns.push(new Star());			patterns.push(new Heart());			patterns.push(new Butterfly());			patterns.push(new Horseshoe());			patterns.push(new Brush(0));						var patternNames = new Array("grass","flower","star","heart","butterfly","paw","brush")						for (var i:int=0;i<patterns.length;i++) {								//patterns[i].cacheAsBitmap = true;								var patSwatch:Pattern = new Pattern(this);								patSwatch.patternName = patternNames[i]												if (patterns[i].isBrush) 	patSwatch.isBrush = true				else 						patSwatch.isBrush = false								//positioning and init				patSwatch.y = 0.9*stage.fullScreenHeight;				patSwatch.x = spacing + (spacing*i);								this.addChild(patSwatch);				patSwatch.setPatternNumber(i);			}						sprayTimer = new flash.utils.Timer(150,0);			sprayTimer.addEventListener(TimerEvent.TIMER,onSpray);					}				public function selectDrawing(drawingClip:MovieClip=null,inDrawingNumber:int=0,inDrawingName:String=null) {						if (Flurry.isSupported) Flurry.logEvent("drawing selected",{drawing:inDrawingName})						curDrawingName = inDrawingName						cookie = SharedObject.getLocal("horsecoloring");																if (cookie.data.drawing0 == undefined ) cookie.data.drawing0 = 0				if (cookie.data.drawing1 == undefined ) cookie.data.drawing1 = 0				if (cookie.data.drawing2 == undefined ) cookie.data.drawing2 = 0				if (cookie.data.drawing3 == undefined ) cookie.data.drawing3 = 0				if (cookie.data.drawing4 == undefined ) cookie.data.drawing4 = 0				if (cookie.data.drawing5 == undefined ) cookie.data.drawing5 = 0												if (inDrawingNumber == 0) cookie.data.drawing0 = cookie.data.drawing0 + 1				if (inDrawingNumber == 1) cookie.data.drawing1 = cookie.data.drawing1 + 1				if (inDrawingNumber == 2) cookie.data.drawing2 = cookie.data.drawing2 + 1				if (inDrawingNumber == 3) cookie.data.drawing3 = cookie.data.drawing3 + 1				if (inDrawingNumber == 4) cookie.data.drawing4 = cookie.data.drawing4 + 1				if (inDrawingNumber == 5) cookie.data.drawing5 = cookie.data.drawing5 + 1															cookie.flush()			if (currentDrawingNumber == inDrawingNumber) {				trace("no need for clear")			}			else {				if (drawingClip == null) {					trace("drawingClip not specified - displaying default drawing")					drawingClip = new Horsedrawing()				}								this.canvas.removeEventListener(TouchEvent.TOUCH_BEGIN,onClickDown)				this.canvas.removeEventListener(TouchEvent.TOUCH_END,onClickUp)				this.canvas.removeEventListener(TouchEvent.TOUCH_OUT,onClickUp)				this.canvas.removeEventListener(TouchEvent.TOUCH_MOVE,onMove)																createBitmaps(drawingClip)					this.canvas.addEventListener(TouchEvent.TOUCH_BEGIN,onClickDown)				this.canvas.addEventListener(TouchEvent.TOUCH_END,onClickUp)				this.canvas.addEventListener(TouchEvent.TOUCH_OUT,onClickUp)				this.canvas.addEventListener(TouchEvent.TOUCH_MOVE,onMove);									currentDrawingNumber = inDrawingNumber							}						if (musicTimer) musicTimer.start()					}						public function createBitmaps(inDrawing:MovieClip) {												//create at startup, clear for consequtive drawings)						if (bmdataColors == null) {																bmdataColors = new BitmapData(stage.fullScreenWidth,picscaleY*stage.fullScreenHeight,true,0x00000000)				bmdataOutlines = new BitmapData(stage.fullScreenWidth,picscaleY*stage.fullScreenHeight,true,0x00000000)				bmdataOriginalOutlines = new BitmapData(stage.fullScreenWidth,picscaleY*stage.fullScreenHeight,true,0x00000000)				bmdataBackdrop = new BitmapData(stage.fullScreenWidth,picscaleY*stage.fullScreenHeight,true,0x00000000)			}			else {						var clearRect:Rectangle = new Rectangle(0,0,stage.fullScreenWidth,stage.fullScreenHeight)				bmdataColors.fillRect(clearRect,0x00000000)				bmdataOutlines.fillRect(clearRect,0x00000000)				bmdataOriginalOutlines.fillRect(clearRect,0x00000000)				bmdataBackdrop.fillRect(clearRect,0x00000000)			}									//load the lineart into the bitmaps			//scale drawing to height and center align			var mat:Matrix = new Matrix()												//don't scale on ipad 2, scale on other devices			var deviceScale:Number = stage.fullScreenHeight/gameHeight			mat.scale(deviceScale,deviceScale)						//var xOffset = Math.ceil((stage.fullScreenWidth - deviceScale*inDrawing.width)/2)			var xOffset = Math.ceil((stage.fullScreenWidth - deviceScale*gameWidth)/2)			mat.translate(xOffset,0)						bmdataColors.drawWithQuality(inDrawing,mat,null,null,null,false,"low")			bmdataOutlines.drawWithQuality(inDrawing,mat,null,null,null,false,"low")			bmdataOriginalOutlines.drawWithQuality(inDrawing,mat,null,null,null,false,"low")						//temp buffer for randomizing the rotation of the stamps and the brush			bmdataPattern = new BitmapData(150,150,true,0x00000000);					}						private function createUtilities() {						createMessage()			//sounds			clickSound = new BrushHitSound()			coloringSongSound = new ColoringSongSound()			natureSoundsSound = new NatureSoundsSong()			musicTimer = new Timer(1000,20)			musicTimer.addEventListener(TimerEvent.TIMER,this.playBackgroundMusic)			musicTimer.start()						resetButton = new ResetButton()			resetButton.scaleX = stage.fullScreenWidth / gameWidth			resetButton.scaleY = stage.fullScreenHeight / gameHeight			resetButton.x = stage.fullScreenWidth - 0.5*resetButton.width - stagePadding			resetButton.y = 0.5*resetButton.height + stagePadding			this.addChild(resetButton);			resetButton.addEventListener(TouchEvent.TOUCH_BEGIN,resetDrawing)			if (CameraRoll.supportsAddBitmapData) {				cameraButton = new CameraButton()				cameraButton.scaleX = stage.fullScreenWidth / gameWidth				cameraButton.scaleY = stage.fullScreenHeight / gameHeight				cameraButton.x = stage.fullScreenWidth * 0.8				cameraButton.y = 0.9*stage.fullScreenHeight				this.addChild(cameraButton);				cameraButton.addEventListener(TouchEvent.TOUCH_BEGIN,saveToCameraRoll)			}						menuButton = new MenuButton()			menuButton.scaleX = stage.fullScreenWidth / gameWidth			menuButton.scaleY = stage.fullScreenHeight / gameHeight			menuButton.x = 0.5*menuButton.width + stagePadding			menuButton.y = 0.5*menuButton.height + stagePadding			this.addChild(menuButton);			menuButton.addEventListener(TouchEvent.TOUCH_BEGIN,gotoMenu)			clickLogo = new soHorsesLogo()			clickLogo.x = gameWidth - clickLogo.width - stagePadding			clickLogo.y = gameHeight - clickLogo.height - stagePadding			//this.addChild(clickLogo)			mainMenu = new Mainmenu(this)			this.addChild(mainMenu)			mainMenu.visible = false			mainMenu.cacheAsBitmap = true						//open on menu			//gotoMenu(null)			//newSession()					}					private function createSurprises() {						boingSound = new BoingSound()			frog = new Frog()			frog.visible = false			this.addChild(frog)			frog.scaleX = stage.fullScreenWidth / gameWidth			frog.scaleY = stage.fullScreenHeight / gameHeight						frog.addEventListener(MouseEvent.RIGHT_CLICK,frogJump)			frog.addEventListener(TouchEvent.TOUCH_BEGIN,frogJump)			surpriseTimer = new Timer(10000)			surpriseTimer.addEventListener(TimerEvent.TIMER,resetFrog)			surpriseTimer.start()						var bee = new Bee(this)																	}				private function frogJump(e:Event) {						//boingSound.play()						var vert = Math.round(-0.3*stage.fullScreenHeight*Math.random()).toString()			TweenMax.to(frog,0.25,{y:vert, repeat:1, yoyo:true})			TweenMax.to(frog,0.5,{x:"200",overwrite:false,onComplete:onEndJump})			this.boingSound.play();		}				private function onEndJump() {			if (frog.x >= stage.fullScreenWidth - frog.width) {				trace("exit frog")				surpriseTimer.delay = 5000 + Math.round(60000*Math.random())				trace(surpriseTimer.delay/1000, "seconds")				frog.visible = false				surpriseTimer.start()			}		}				public function resetFrog(e:Event) {			surpriseTimer.stop()									if (!frog.visible) {				boingSound.play()							frog.visible = true				frog.x = Math.round((stage.fullScreenWidth/2)*Math.random())				frog.y = -frog.height				TweenMax.to(frog,2,{y:0.67*stage.fullScreenHeight, ease:Bounce.easeOut})			}						}				public function playBackgroundMusic(e:TimerEvent) {						if (songChannel) songChannel.stop()			natureSongChannel = natureSoundsSound.play()			musicTimer.delay = 60000		}						private function createMessage() {			msg = new Message()						addChild(msg)			msg.scaleX = stage.fullScreenWidth / gameWidth			msg.scaleY = stage.fullScreenHeight / gameHeight			msg.x = stage.fullScreenWidth / 2 - msg.width/2			msg.y = 0.66*stage.fullScreenHeight			msg.visible = false		}				public function alert(str:String,icon=null) {			this.setChildIndex(msg,this.numChildren-1);			msg.Show(str,icon)					}						private function createBackground() {			var background = this.addChild(new Background())			this.setChildIndex(background,0)		}				private function gotoMenu(e:Event) {			releaseButtons()			TweenMax.to(menuButton, 0.3, {scaleX:"0.2", scaleY:"0.2", repeat:1, ease:Cubic.easeInOut, yoyo:true});			mainMenu.show("animated")			this.clickSound.play()			if (natureSongChannel) natureSongChannel.stop()			musicTimer.reset()		}				private function newSession() {			mainMenu.show("direct")			if (natureSongChannel) natureSongChannel.stop()			musicTimer.reset()							}						private function saveToCameraRoll(e:Event) {						cameraButton.removeEventListener(TouchEvent.TOUCH_BEGIN,saveToCameraRoll)			releaseButtons()			animBounce(cameraButton,cameraButton.scaleX,cameraButton.scaleY)			var camroll:CameraRoll = new CameraRoll()			camroll.addEventListener(Event.COMPLETE,onSavedToCameraRoll)			camroll.addEventListener(ErrorEvent.ERROR,onCameraRollError)						if (CameraRoll.supportsAddBitmapData) {				var bmdataAll:BitmapData = new BitmapData(stage.fullScreenWidth,picscaleY*stage.fullScreenHeight)				//var bmdataAll:BitmapData = new BitmapData(stage.fullScreenWidth,stage.fullScreenHeight,false,0xFF0000)				bmdataAll.draw(this.bmdataColors)				bmdataAll.draw(this.bmdataBackdrop)				camroll.addBitmapData(bmdataAll)				var shuttersound:Sound = new ShutterSound()				shuttersound.play()				if (Flurry.isSupported) Flurry.logEvent("saved to camera roll",{drawing:curDrawingName})			}			else {				console.log("savind to camera roll not supported on this device")				if (Flurry.isSupported) Flurry.logEvent("failed save to camera roll",{drawing:curDrawingName})			}					}				private function onSavedToCameraRoll(e:Event) {			alert("Drawing saved to camera roll")			cameraButton.addEventListener(TouchEvent.TOUCH_BEGIN,saveToCameraRoll)		}						private function onCameraRollError(e:ErrorEvent) {			this.console.log(e.text + " - " + e.errorID)			alert("Drawing not saved. Please enable cameraroll saving for this app in settings/privacy/photo's")			cameraButton.addEventListener(TouchEvent.TOUCH_BEGIN,saveToCameraRoll)		}				public function releaseButtons() {			if (lastClicked) lastClicked.releaseFocus()			}																private function resetDrawing(e:Event) {			TweenMax.to(this.resetButton, 0.3, {scaleX:"0.2", scaleY:"0.2", repeat:1, ease:Cubic.easeInOut, yoyo:true, onComplete:releaseResetButton});			resetButton.removeEventListener(TouchEvent.TOUCH_BEGIN,resetDrawing)			bmdataColors.fillRect(new Rectangle(0,0,stage.fullScreenWidth,stage.fullScreenHeight),0x00000000)			bmdataOutlines.fillRect(new Rectangle(0,0,stage.fullScreenWidth,stage.fullScreenHeight),0x00000000)			bmdataPattern.fillRect(new Rectangle(0,0,stage.fullScreenWidth,stage.fullScreenHeight),0x00000000)			bmdataBackdrop.fillRect(new Rectangle(0,0,stage.fullScreenWidth,stage.fullScreenHeight),0x00000000)			redrawOriginalDrawing()			releaseButtons()				this.clickSound.play()			if (Flurry.isSupported) Flurry.logEvent("reset drawing")		}		private function releaseResetButton() {			trace("ready")			resetButton.addEventListener(TouchEvent.TOUCH_BEGIN,resetDrawing)		}		private function createInApps() {			//inAppManager = new InappManager(this)		}		public function onPaid(e:Event) {						this.payingUser = true			cookie = SharedObject.getLocal("horsecoloring");			cookie.data.payingUser = true			cookie.flush()			trace("setting paying user cookie: ",cookie.data.payingUser)					}				//LOAD USER DATA FROM COOKIE		public function loadUserData() {															cookie = SharedObject.getLocal("horsecoloring");									if (cookie.data.payingUser == true ) {				this.payingUser = true							}												if (cookie.data.numPlays == undefined ) cookie.data.numPlays = 1			else cookie.data.numPlays = cookie.data.numPlays + 1			this.numPlays = cookie.data.numPlays						cookie.flush()						}				private function createDebugConsole() {			console = new DebugConsole(this)			console.log("Debug console")					}						public function getChildren(dsObject:DisplayObjectContainer, iDepth:int = 0):void {			 var i:int = 0;			 var sDummyTabs:String = "";			 var dsoChild:DisplayObject;					 for (i ; i < iDepth ; i++)				 sDummyTabs += "\t";					 trace(sDummyTabs + dsObject);					 for (i = 0; i < dsObject.numChildren ; ++i)			 {				 dsoChild = dsObject.getChildAt(i);				 if (dsoChild is DisplayObjectContainer && 0 < DisplayObjectContainer(dsoChild).numChildren)					 getChildren(dsoChild as DisplayObjectContainer,++iDepth);				 else					 trace(sDummyTabs,i,dsoChild);			 }		}	}	}